buildscript {
    repositories {
        mavenCentral()
    }
}

plugins {
    id "io.spring.dependency-management" version "0.5.6.RELEASE"
}

ext {
    easymockVersion = "3.4"
    hamcrestVersion = "1.3"
    assertjVersion = "3.4.1"
    cglibVersion = "2.2.2"
    objenesisVersion = "2.2"
    javassistVersion = "3.20.0-GA"
    junitVersion = "4.12"
    junitRulesVersion = "4.8.2"
    testngVersion = "6.9.10"
    xstreamVersion = "1.4.9"
    mockito1Version = "1.10.19"
    mockito2Version = "2.0.51-beta"

    ext.gradleScriptDir = "${rootProject.projectDir}/gradle"
}

description = 'PowerMock allows you to unit test code normally regarded as untestable.\n' +
        '        For instance it is possible to mock static methods, remove static initializers, allow mocking without dependency\n' +
        '        injection and more.\n' +
        '        PowerMock works by bytecode manipulation.\n' +
        '        PowerMock also contain some utilities that gives you easier access to an objects internal state.\n' +
        '        PowerMock can be used to test otherwise untestable code and also to achieve a cleaner separation between test\n' +
        '        and production code.'

apply from: "${gradleScriptDir}/version.gradle"
apply from: "${gradleScriptDir}/ide.gradle"

configure(allprojects) { project ->
    repositories {
        mavenCentral()
    }

    group = 'org.powermock'

    apply plugin: "io.spring.dependency-management"

    dependencyManagement {
        dependencies {
            dependency("org.objenesis:objenesis:${objenesisVersion}")
            dependency("org.javassist:javassist:${javassistVersion}")
            dependency("org.assertj:assertj-core:${assertjVersion}")
            dependency("org.hamcrest:hamcrest-core:${hamcrestVersion}")
            dependency("junit:junit:${junitVersion}") {
                exclude group: 'org.hamcrest', module: 'hamcrest-core'
            }
        }
    }

    apply plugin: "java"

    compileJava {
        sourceCompatibility = 1.6
        targetCompatibility = 1.6
    }

    compileTestJava {
        sourceCompatibility = 1.6
        targetCompatibility = 1.6
        options.compilerArgs += "-parameters"
    }

    tasks.withType(JavaCompile) {
        options.warnings = false
    }

    configurations {
        mockito1TestCompile.extendsFrom testCompile
        mockito2TestCompile.extendsFrom testCompile
    }

    sourceSets {
        mockito1 {
            java.srcDirs = ['src/test']
            resources.srcDirs = ['src/test/resources']
            output.resourcesDir = 'build/mockito1/classes/test'
            output.classesDir   = 'build/mockito1/classes/test'
            compileClasspath = sourceSets.main.output + configurations.mockito1TestCompile
            runtimeClasspath = output + compileClasspath  + configurations.mockito1TestCompile
            sourceCompatibility = 1.6
            targetCompatibility = 1.6
        }
        mockito2 {
            java.srcDirs = ['src/test']
            resources.srcDirs = ['src/test/resources']
            output.resourcesDir = 'build/mockito2/classes/test'
            output.classesDir   = 'build/mockito2/classes/test'
            compileClasspath = sourceSets.main.output + configurations.mockito2TestCompile
            runtimeClasspath = output + compileClasspath  + configurations.mockito1TestCompile
            sourceCompatibility = 1.6
            targetCompatibility = 1.6
        }
    }

    task mockito1Test(type: Test) {
        description = 'Runs the test with Mockito 1'
        group = 'verification'
        testClassesDir = sourceSets.mockito1.output.classesDir
        classpath = sourceSets.mockito1.runtimeClasspath

        testLogging {
            events "passed", "skipped", "failed"
            exceptionFormat = 'full'
            showStandardStreams = true
            afterSuite { desc, result ->
                if (!desc.parent) { // will match the outermost suite
                    println "Results: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} successes, ${result.failedTestCount} failures, ${result.skippedTestCount} skipped)"
                }
            }
        }

        reports.junitXml.destination = 'build/mockito1-test-results'
        reports.html.destination = 'build/reports/mockito1Test'
    }

    task mockito2Test(type: Test) {
        description = 'Runs the test with Mockito 2'
        group = 'verification'
        testClassesDir = sourceSets.mockito2.output.classesDir
        classpath = sourceSets.mockito2.runtimeClasspath

        testLogging {
            events "passed", "skipped", "failed"
            exceptionFormat = 'full'
            showStandardStreams = true
            afterSuite { desc, result ->
                if (!desc.parent) { // will match the outermost suite
                    println "Results: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} successes, ${result.failedTestCount} failures, ${result.skippedTestCount} skipped)"
                }
            }
        }

        reports.junitXml.destination = 'build/mockito2-test-results'
        reports.html.destination = 'build/reports/mockito2Test'
    }

    test{
        testLogging {
            events "passed", "skipped", "failed"
            exceptionFormat = 'full'
            showStandardStreams = true
        }
    }

    mockito1Test.mustRunAfter test
    mockito2Test.mustRunAfter test
}

task wrapper(type: Wrapper) {
    gradleVersion = '2.13'
}

project("powermock-reflect") {
    description = "Various utilities for accessing internals of a class."

    dependencies {
        compile("org.objenesis:objenesis")
        testCompile("junit:junit")
        testCompile("org.hamcrest:hamcrest-core")
    }

    test{
        testLogging {
            events "passed", "skipped", "failed"
            exceptionFormat = 'full'
            showStandardStreams = true
            afterSuite { desc, result ->
                if (!desc.parent) { // will match the outermost suite
                    println "Results: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} successes, ${result.failedTestCount} failures, ${result.skippedTestCount} skipped)"
                }
            }
        }
    }
}

project("powermock-core") {
    description = "Various utilities for accessing internals of a class."

    dependencies {
        compile(project(":powermock-reflect"))
        compile("org.javassist:javassist")
        testCompile("junit:junit")
        testCompile("org.assertj:assertj-core")
        testCompile("org.hamcrest:hamcrest-core")
        mockito1TestCompile("org.mockito:mockito-core:${mockito1Version}")
        mockito2TestCompile("org.mockito:mockito-core:${mockito2Version}")
    }

    compileTestJava{
        enabled = false
    }

    test{
        dependsOn("mockito1Classes","mockito2Classes")
    }

    check.dependsOn mockito1Test,mockito2Test

}